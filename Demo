/ Skip duplicates

if (i > index && input[i] == input[i - 1])

continue;

// Add the current element to the subset currentSubset.add(input[i]);

// Recursively generate subsets starting from the next index generateSubsets (input, i + 1, currentSubset, subsets);

// Remove the current element from the subset to backtrack currentSubset.remove(currentSubset.size() - 1);

public static void printSubsets(int[] input) {

ArrayList<ArrayList<Integer>> subsets = getSubsets (input);



subsets.add(new ArrayList<>(currentSubset));

for (int i index; i < input.length; i++) {



ArrayList<ArrayList<Integer>> subsets = new ArrayList<>();

ArrayList<Integer> currentSubset = new ArrayList<>();

generateSubsets (input,, currentSubset, subsets);



import java.util.*;

public class Solution {

    public static List<List<Integer>> getSubsets(int[] input) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        findSubsets(input, 0, currentSubset, result);
        return result;
    }

    private static void findSubsets(int[] input, int index, List<Integer> currentSubset, List<List<Integer>> result) {
        // Add the current subset to the result
        result.add(new ArrayList<>(currentSubset));

        // Explore further subsets
        for (int i = index; i < input.length; i++) {
            // To avoid duplicates, skip elements that are the same as the previous one
            if (i > index && input[i] == input[i - 1]) continue;

            // Include current element in the subset
            currentSubset.add(input[i]);

            // Recursively generate further subsets
            findSubsets(input, i + 1, currentSubset, result);

            // Backtrack by removing the last element added
            currentSubset.remove(currentSubset.size() - 1);
        }
    }

    public static void main(String[] args) {
        // Input reading
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] input = new int[n];

        for (int i = 0; i < n; i++) {
            input[i] = sc.nextInt();
        }

        // Get the subsets
        List<List<Integer>> subsets = getSubsets(input);

        // Output the result
        for (List<Integer> subset : subsets) {
            System.out.println(subset);
        }
    }
}









import java.util.*;

public class Solution {
    
    public static List<List<Integer>> getSubsets(int[] input) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        findSubsets(input, 0, currentSubset, result);
        return result;
    }
    
    private static void findSubsets(int[] input, int index, List<Integer> currentSubset, List<List<Integer>> result) {
        // Add the current subset to the result
        result.add(new ArrayList<>(currentSubset));
        
        // Explore further subsets
        for (int i = index; i < input.length; i++) {
            // To avoid duplicates, skip elements that are the same as the previous one
            if (i > index && input[i] == input[i - 1]) continue;
            
            // Include current element in the subset
            currentSubset.add(input[i]);
            
            // Recursively generate further subsets
            findSubsets(input, i + 1, currentSubset, result);
            
            // Backtrack by removing the last element added
            currentSubset.remove(currentSubset.size() - 1);
        }
    }
    
    public static void main(String[] args) {
        // Input reading
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] input = new int[n];
        
        for (int i = 0; i < n; i++) {
            input[i] = sc.nextInt();
        }
        
        // Get the subsets
        List<List<Integer>> subsets = getSubsets(input);
        
        // Output the result
        for (List<Integer> subset : subsets) {
            System.out.println(subset);
        }
    }
}







class Solution {

public static Node<Integer> kReverse (Node<Integer> head, int k) {

if (k=0|| k == 1) {

return head;

}

Node<Integer> current = head;

Node<Integer> fwd = null;

Node<Integer> prev = null;

int count = 0;

/* Reverse first k nodes of linked list */

while (count < k && current != null) {

fwd = current.next;

current.next = prev;

prev = current;

current = fwd;

count++;

}

if (fwd != null) {

head.next = kReverse(fwd, k); I

}

return prev;

}





import java.util.ArrayList;

import java.util.Arrays;

public class Solution {

public static ArrayList<ArrayList<Integer>> getSubsets(int[] input) {

// Sort the input array (if it's not already sorted)

Arrays.sort(input);

ArrayList<ArrayList<Integer>> subsets = new ArrayList<>();

ArrayList<Integer> currentSubset = new ArrayList<>();

generateSubsets (input, 0, currentSubset, subsets);

I

return subsets;

}

private static void generateSubsets (int[] input, int index, ArrayList<Integer> currentSubset, ArrayLis

// Add the current subset to the list of subsets

subsets.add(new ArrayList<>(currentSubset));

for (int i = index; i < input.length; i++) {
for (int i = index; i < input.length; i++) {

// Skip duplicates

if (i > index && input[i] == input[i - 1])

continue;

// Add the current element to the subset

currentSubset.add(input[i]);

// Recursively generate subsets starting from the next index generateSubsets (input, i + 1, currentSubset, subsets);

// Remove the current element from the subset to backtrack currentSubset.remove(currentSubset.size() - 1);

-}

}

public static void printSubsets (int[] input) {

ArrayList<ArrayList<Integer>> subsets = getSubsets (input);

// Print the subsets

for ArrayList<Integers subset subsets) {
// Recursively generate subsets starting from the next index generateSubsets(input, i + 1, currentSubset, subsets);

// Remove the current element from the subset to backtrack

currentSubset.remove(currentSubset.size() - 1);

}

}

public static void printSubsets(int[] input) {

ArrayList<ArrayList<Integer>> subsets = getSubsets (input);

// Print the subsets

for (ArrayList<Integer> subset: subsets) {

for (int num: subset) {

System.out.print(num + " ");

}

System.out.println();

}

I

}

}



Subject: Request for Claim Reassessment

Dear [Insurance Company Name/Claims Department],

I hope this email finds you well. I am writing regarding the rejection of my recent medical claim [Claim ID/Policy Number, if available].

To assist in the review process, I have attached documents from the past three years for your reference. These documents demonstrate the consistency of my claims and the validity of my current submission.

I kindly request you to review the attached documents and reconsider the decision. Your assistance in resolving this matter promptly will be greatly appreciated.

Please let me know if you require any further information from my side.

Thank you for your time and support.




Dear [Insurance Company Name/Claims Department],

I hope this email finds you well. I am writing to inquire about the rejection of my recent medical claim [Claim ID/Policy Number, if available].

I noticed that a similar claim submitted previously was approved without any issues. However, this time, despite the circumstances and details being identical, the claim was rejected. I am unable to understand the reason behind this decision and would appreciate clarification on the matter.

Kindly provide the specific reasons for the rejection and let me know if any additional information or documentation is required from my end to resolve this issue.

I look forward to your prompt response to address this concern.

Thank you for your time and assistance.






class Node<T> {
    T data;
    Node<T> next;

    public Node(T data) {
        this.data = data;
        this.next = null;
    }
}

public class Solution {

    public static Node<Integer> appendLastNToFirst(Node<Integer> head, int n) {
        // Handle empty list or no rearrangement needed
        if (head == null || n == 0) {
            return head;
        }

        // Step 1: Find the length of the linked list
        int length = 0;
        Node<Integer> current = head;
        while (current != null) {
            length++;
            current = current.next;
        }

        // Step 2: If N equals length, no change needed
        if (n == length) {
            return head;
        }

        // Step 3: Find the (length - N)th node (the new tail)
        current = head;
        int count = 1;
        while (count < length - n) {
            current = current.next;
            count++;
        }

        // Step 4: Rearrange pointers
        Node<Integer> newHead = current.next;
        current.next = null;  // Make current node the new tail
        Node<Integer> temp = newHead;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = head;  // Make the old head the next of the last node
        
        // Return the new head
        return newHead;
    }
}
2)..

class Node<T> {
    T data;
    Node<T> next;

    public Node(T data) {
        this.data = data;
        this.next = null;
    }
}

public class Solution {

    public static Node<Integer> removeDuplicates(Node<Integer> head) {
        // Edge case: If the list is empty or has only one element, no duplicates to remove
        if (head == null || head.next == null) {
            return head;
        }

        Node<Integer> current = head;

        // Traverse the list
        while (current != null && current.next != null) {
            // Check if current node's data is equal to next node's data
            if (current.data.equals(current.next.data)) {
                // Skip the next node
                current.next = current.next.next;
            } else {
                // Move to the next node
                current = current.next;
            }
        }
        return head;
    }
}


3)

class Node<T> {
    T data;
    Node<T> next;

    public Node(T data) {
        this.data = data;
        this.next = null;
    }
}

public class Solution {

    public static void printReverse(Node<Integer> root) {
        // Base case: If the node is null, return
        if (root == null) {
            return;
        }

        // Recursive call on the next node
        printReverse(root.next);

        // Print the current node's data after the recursion has reached the end
        System.out.print(root.data);
    }
}


4.

class Node<T> {
    T data;
    Node<T> next;

    public Node(T data) {
        this.data = data;
        this.next = null;
    }
}

public class Solution {

    // Function to find the middle of the linked list
    private static Node<Integer> findMiddle(Node<Integer> head) {
        Node<Integer> slow = head;
        Node<Integer> fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    // Function to reverse a linked list
    private static Node<Integer> reverseList(Node<Integer> head) {
        Node<Integer> prev = null;
        Node<Integer> curr = head;

        while (curr != null) {
            Node<Integer> nextNode = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextNode;
        }
        return prev;
    }

    // Function to check if the linked list is a palindrome
    public static boolean isPalindrome(Node<Integer> head) {
        // Edge case: if the list is empty or has only one element, it's a palindrome
        if (head == null || head.next == null) {
            return true;
        }

        // Step 1: Find the middle of the list
        Node<Integer> middle = findMiddle(head);

        // Step 2: Reverse the second half of the list
        Node<Integer> secondHalf = reverseList(middle);

        // Step 3: Compare the first and second halves
        Node<Integer> firstHalf = head;
        Node<Integer> secondHalfCopy = secondHalf;

        while (secondHalfCopy != null) {
            if (!firstHalf.data.equals(secondHalfCopy.data)) {
                return false; // If mismatch found, it's not a palindrome
            }
            firstHalf = firstHalf.next;
            secondHalfCopy = secondHalfCopy.next;
        }

        return true; // If no mismatch, the list is a palindrome
    }
}
new...


public static Node<Integer> deleteNodeRec(Node<Integer> head, int pos) {
    // Base case: If the list is empty or position is invalid
    if (head == null) {
        return null;
    }

    // Base case: If the current node is to be deleted
    if (pos == 0) {
        return head.next; // Skip the current node
    }

    // Recursive call for the next node
    head.next = deleteNodeRec(head.next, pos - 1);

    return head; // Return the current head
}

...

public static Node<Integer> reverseRec(Node<Integer> head) {
    // Base case: If the list is empty or has one node
    if (head == null || head.next == null) {
        return head;
    }

    // Recursively reverse the rest of the list
    Node<Integer> reversedHead = reverseRec(head.next);

    // Adjust the current node's next pointer
    head.next.next = head;
    head.next = null;

    // Return the new head of the reversed list
    return reversedHead;
}
....

public static Node<Integer> reverse_I(Node<Integer> head) {
    // Initialize three pointers
    Node<Integer> prev = null;
    Node<Integer> curr = head;
    Node<Integer> next = null;

    // Iterate through the list
    while (curr != null) {
        // Save the next node
        next = curr.next;

        // Reverse the current node's pointer
        curr.next = prev;

        // Move pointers one step forward
        prev = curr;
        curr = next;
    }

    // Return the new head (prev)
    return prev;
}

...

public static Node<Integer> midPoint(Node<Integer> head) {
    // If the list is empty or has only one node
    if (head == null || head.next == null) {
        return head;
    }

    // Initialize slow and fast pointers
    Node<Integer> slow = head;
    Node<Integer> fast = head;

    // Move pointers until fast or fast.next reaches the end
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // Slow is now pointing to the midpoint
    return slow;
}


....

public static Node<Integer> mergeTwoSorted(Node<Integer> head1, Node<Integer> head2) {
    // If one of the lists is empty, return the other list
    if (head1 == null) {
        return head2;
    }
    if (head2 == null) {
        return head1;
    }

    // Initialize the merged list's head
    Node<Integer> mergedHead = null, mergedTail = null;

    // Set the initial mergedHead and mergedTail
    if (head1.data <= head2.data) {
        mergedHead = head1;
        mergedTail = head1;
        head1 = head1.next;
    } else {
        mergedHead = head2;
        mergedTail = head2;
        head2 = head2.next;
    }

    // Traverse both lists and merge
    while (head1 != null && head2 != null) {
        if (head1.data <= head2.data) {
            mergedTail.next = head1;
            mergedTail = head1;
            head1 = head1.next;
        } else {
            mergedTail.next = head2;
            mergedTail = head2;
            head2 = head2.next;
        }
    }

    // Attach the remaining nodes (if any)
    if (head1 != null) {
        mergedTail.next = head1;
    } else {
        mergedTail.next = head2;
    }

    return mergedHead;
}


...
public static Node<Integer> mergeSort(Node<Integer> head) {
    // Base case: if the list has 0 or 1 node
    if (head == null || head.next == null) {
        return head;
    }

    // Find the middle of the list
    Node<Integer> mid = getMiddle(head);
    Node<Integer> half = mid.next;
    mid.next = null; // Split the list into two halves

    // Recursively sort both halves
    Node<Integer> left = mergeSort(head);
    Node<Integer> right = mergeSort(half);

    // Merge the two sorted halves
    return mergeTwoSorted(left, right);
}

private static Node<Integer> getMiddle(Node<Integer> head) {
    if (head == null) {
        return head;
    }

    Node<Integer> slow = head;
    Node<Integer> fast = head;

    // Move fast by 2 steps and slow by 1 step to find the middle
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    return slow;
}

private static Node<Integer> mergeTwoSorted(Node<Integer> head1, Node<Integer> head2) {
    if (head1 == null) {
        return head2;
    }
    if (head2 == null) {
        return head1;
    }

    Node<Integer> mergedHead;
    if (head1.data <= head2.data) {
        mergedHead = head1;
        mergedHead.next = mergeTwoSorted(head1.next, head2);
    } else {
        mergedHead = head2;
        mergedHead.next = mergeTwoSorted(head1, head2.next);
    }

    return mergedHead;
}

...

public class Solution {
    public static int findNodeRec(Node<Integer> head, int n) {
        // Base case: if head is null, return -1 (indicating not found)
        if (head == null) {
            return -1;
        }
        
        // If current node's data is equal to n, return the current index (which is 0 at this point)
        if (head.data == n) {
            return 0;
        }
        
        // Recurse into the next node, and add 1 to the result (index in the next node)
        int indexInNextNode = findNodeRec(head.next, n);
        
        // If the result is not -1, it means the element was found in the subsequent nodes
        if (indexInNextNode != -1) {
            return indexInNextNode + 1;
        }
        
        // If the element wasn't found in the list, return -1
        return -1;
    }
}

.....


public class Solution {
    public static Node<Integer> evenAfterOdd(Node<Integer> head) {
        // Edge case: If the list is empty or has only one node, return it directly.
        if (head == null || head.next == null) {
            return head;
        }

        // Initialize two dummy nodes for odd and even lists.
        Node<Integer> oddHead = new Node<>(0);  // Dummy head for odd list
        Node<Integer> evenHead = new Node<>(0); // Dummy head for even list

        Node<Integer> odd = oddHead;  // Pointer for odd list
        Node<Integer> even = evenHead;  // Pointer for even list

        Node<Integer> current = head;

        // Traverse the list and divide nodes into odd and even lists.
        while (current != null) {
            if (current.data % 2 != 0) {
                odd.next = current;  // Add to odd list
                odd = odd.next;
            } else {
                even.next = current;  // Add to even list
                even = even.next;
            }
            current = current.next;
        }

        // To avoid circular references, mark the end of the even list.
        even.next = null;

        // Connect odd list to even list.
        odd.next = evenHead.next;

        // Return the head of the new list, which is oddHead.next (skipping dummy node).
        return oddHead.next;
    }
}


...

public class Solution {
    public static Node<Integer> skipMdeleteN(Node<Integer> head, int M, int N) {
        // Base case: If the head is null or M is 0 (delete all nodes), return null
        if (head == null || M == 0) {
            return null;
        }

        Node<Integer> current = head;
        Node<Integer> temp = null;
        
        while (current != null) {
            // Retain M nodes
            for (int i = 1; i < M && current != null; i++) {
                current = current.next;
            }

            // If current is null, exit the loop
            if (current == null) {
                break;
            }

            // Now, current points to the M-th node, disconnect it from the next part of the list
            temp = current.next;
            
            // Delete the next N nodes
            for (int i = 1; i <= N && temp != null; i++) {
                temp = temp.next;
            }

            // Connect the M-th node to the (M+N)-th node
            current.next = temp;
            
            // Move the current pointer to the next retained node
            current = temp;
        }

        return head;
    }
}
......

public class Solution {
    public static Node<Integer> swapNodes(Node<Integer> head, int i, int j) {
        // If i and j are the same, no swap is needed
        if (i == j) {
            return head;
        }

        // Initialize pointers for traversal
        Node<Integer> prevI = null, currI = head;
        Node<Integer> prevJ = null, currJ = head;

        // Find the i-th and j-th nodes along with their previous nodes
        for (int idx = 0; currI != null && idx < i; idx++) {
            prevI = currI;
            currI = currI.next;
        }
        for (int idx = 0; currJ != null && idx < j; idx++) {
            prevJ = currJ;
            currJ = currJ.next;
        }

        // If either of the nodes is not found (i or j is out of bounds), return the original list
        if (currI == null || currJ == null) {
            return head;
        }

        // If i-th node is not the head, update the previous node to point to the j-th node
        if (prevI != null) {
            prevI.next = currJ;
        } else {
            // If i-th node is the head, update the head to point to the j-th node
            head = currJ;
        }

        // If j-th node is not the head, update the previous node to point to the i-th node
        if (prevJ != null) {
            prevJ.next = currI;
        } else {
            // If j-th node is the head, update the head to point to the i-th node
            head = currI;
        }

        // Swap the next pointers of the i-th and j-th nodes
        Node<Integer> temp = currI.next;
        currI.next = currJ.next;
        currJ.next = temp;

        return head;
    }
}
....

public class Solution {
    
    // Helper function to reverse a sublist of k nodes
    private static Node<Integer> reverseKNodes(Node<Integer> head, int k) {
        Node<Integer> prev = null;
        Node<Integer> curr = head;
        Node<Integer> next = null;
        int count = 0;
        
        // Reverse the first k nodes
        while (curr != null && count < k) {
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
            count++;
        }
        
        // Return the new head of the reversed sublist
        return prev;
    }

    public static Node<Integer> reverseKGroup(Node<Integer> head, int k) {
        // Check for the edge case where the list is empty or k is 1
        if (head == null || k == 1) {
            return head;
        }

        Node<Integer> dummy = new Node<>(0); // Dummy node to simplify edge cases
        dummy.next = head;
        Node<Integer> groupPrev = dummy; // This will point to the node before each group
        Node<Integer> groupEnd = head; // This will point to the last node in each group
        
        while (groupEnd != null) {
            // Move the groupEnd pointer k steps forward
            int count = 0;
            while (count < k && groupEnd != null) {
                groupEnd = groupEnd.next;
                count++;
            }
            
            // If we have k nodes to reverse
            if (count == k) {
                Node<Integer> groupStart = groupPrev.next;
                Node<Integer> groupNext = groupEnd;
                
                // Reverse the k nodes
                Node<Integer> reversedGroupHead = reverseKNodes(groupStart, k);
                
                // Connect the previous part to the reversed part
                groupPrev.next = reversedGroupHead;
                
                // Connect the end of the reversed group to the rest of the list
                groupStart.next = groupNext;
                
                // Move the groupPrev pointer k nodes forward
                groupPrev = groupStart;
            }
        }
        
        return dummy.next;
    }
}
..
.....

class Node<T> {
    T data;
    Node<T> next;

    public Node(T data) {
        this.data = data;
        this.next = null;
    }
}

public class Solution {

    // Function to perform bubble sort on a singly linked list
    public static Node<Integer> bubbleSort(Node<Integer> head) {
        if (head == null || head.next == null) {
            return head; // If list is empty or has one node, no sorting needed
        }

        boolean swapped;
        Node<Integer> current;
        Node<Integer> lastSorted = null;

        // Keep making passes through the list until no swaps are done
        do {
            swapped = false;
            current = head;

            // Traverse the list, compare adjacent nodes, and swap if needed
            while (current != null && current.next != lastSorted) {
                if (current.data > current.next.data) {
                    // Swap the data of the nodes
                    int temp = current.data;
                    current.data = current.next.data;
                    current.next.data = temp;

                    swapped = true;
                }
                current = current.next;
            }

            // After each pass, the last element is sorted
            lastSorted = current;

        } while (swapped);  // Continue until no swaps are done

        return head;
    }
}
......

class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class Stack {
    private Node top;  // Points to the top of the stack
    private int size;  // To keep track of the size of the stack

    // Constructor to initialize the stack
    public Stack() {
        this.top = null;
        this.size = 0;
    }

    // Push function: adds an element to the top of the stack
    public void push(int data) {
        Node newNode = new Node(data);
        newNode.next = top;  // New node points to the previous top
        top = newNode;       // Now, the new node becomes the top
        size++;              // Increment the size
    }

    // Pop function: removes the top element from the stack
    public int pop() {
        if (top == null) {  // Stack is empty
            return -1;
        }
        int poppedData = top.data;  // Save the data to return
        top = top.next;  // Remove the top node
        size--;  // Decrease the size
        return poppedData;
    }

    // Top function: returns the top element without removing it
    public int top() {
        if (top == null) {  // Stack is empty
            return -1;
        }
        return top.data;
    }

    // Size function: returns the size of the stack
    public int size() {
        return size;
    }

    // isEmpty function: checks if the stack is empty
    public boolean isEmpty() {
        return top == null;
    }

    public static void main(String[] args) {
        Stack stack = new Stack();
        
        // Sample Input 1
        stack.push(13);
        stack.push(47);
        System.out.println(stack.size());  // Output: 2
        System.out.println(stack.isEmpty());  // Output: false
        System.out.println(stack.pop());  // Output: 47
        System.out.println(stack.top());  // Output: 13

        // Sample Input 2
        stack = new Stack();
        System.out.println(stack.isEmpty());  // Output: true
        System.out.println(stack.pop());  // Output: -1
        stack.push(10);
        System.out.println(stack.isEmpty());  // Output: false
    }
}

import java.util.Stack;

public class Solution {
    public static void reverseStack(Stack<Integer> input, Stack<Integer> extra) {
        // Step 1: Move all elements from input to extra to reverse the stack
        while (!input.isEmpty()) {
            extra.push(input.pop());
        }

        // Step 2: Transfer the reversed elements back to input
        while (!extra.isEmpty()) {
            input.push(extra.pop());
        }
    }

    public static void main(String[] args) {
        // Sample Test Case 1
        Stack<Integer> input = new Stack<>();
        Stack<Integer> extra = new Stack<>();
        
        // Simulating the input stack
        input.push(10);
        input.push(5);
        input.push(4);
        input.push(3);
        input.push(2);
        input.push(1);

        // Reversing the stack
        reverseStack(input, extra);

        // Printing the reversed stack
        while (!input.isEmpty()) {
            System.out.print(input.pop() + " ");
        }
    }
}


......
import java.util.Stack;

public class Solution {
    public static boolean checkRedundantBrackets(String expression) {
        Stack<Character> stack = new Stack<>();
        
        for (char ch : expression.toCharArray()) {
            if (ch == ')') {
                char top = stack.peek();
                stack.pop();
                int elementsInside = 0;
                
                // Check if there is an operator inside the brackets
                while (top != '(') {
                    elementsInside++;
                    top = stack.peek();
                    stack.pop();
                }
                
                // If there are no elements between brackets, it is redundant
                if (elementsInside == 0) {
                    return true;
                }
            } else {
                stack.push(ch);
            }
        }
        
        return false;
    }

    public static void main(String[] args) {
        String expression1 = "a+(b)+c";
        String expression2 = "(a+b)";
        
        System.out.println(checkRedundantBrackets(expression1));  // Output: true
        System.out.println(checkRedundantBrackets(expression2));  // Output: false
    }
}
.....new

public boolean isPalindromePair(ArrayList<String> words) {

for (String word: words) {

this.add(reverseword (word));

}

return isPalindromePair(this.root, words);

I

private static String reverseword(String word) {

String reverse = "";

for(int i= word.length() - 1; i >= 0; i--) {

reverse + word.charAt(i);

}

return reverse;

}

private boolean isPalindromePair(TrieNode root. ArrayList<String> words) {
private boolean isPalindromePair (TrieNode root, ArrayList<String> words) {

if (words == null || words.size() == 0) {

return false;

}

for (String word: words) {

if (doesPairExistFor (root, word, 0)) {

return true;

}

{ر

return false;

}

private boolean doesPairExistFor (TrieNode root, String word, int startIndex) { /* Since an empty string is always a palindrome, we return 'true' */

if (word = "") {

return true;

}
if (startIndex == word.length()) {

if (root.isTerminating) {

When there exists an exact match of the word we are

searching for in the Trie, irrespective of the trie

extends further in the same path.

return true;

}

When trie extends further, there doesnt exist an exact

* match of the string we are looking for.

However, it may happen that any of the the branch extending from root may form a palindrome.

I

return checkRemainingBranchesInTrie(root, "");

}

int charIndex = word.charAt(startIndex) - 'a';

TrieNode correspondingChild = root.children[charIndex];

if (correspondingChild == null) {

/*

This means that, down the line in the characters that we are looking

for against the word in the trie, the character doesn't exist in the trie.

This character can be anywhere in the range [0 (word length-1)]

if (root.isTerminating) {

return checkWordForPalindrome (word.substring(startIndex));

}

return false;

}

return doespairExistFor (correspondingChild, word, (startIndex + 1));

}
private boolean checkRemainingBranches InTrie (TrieNode root, String word) {

*

* This function recursively explores all the branches from the root * while keeping a track of the characters in the 'word' and checks

* each word whenever the terminating condition is true.

*

* If the word is a palindrome, we return true and stops exploring the other branches. If it is otherwise, we keep on checking the remaining * branches.

*

* Once all the branches are explored, and we don't find any branch or word that makes itself a palindrome we return false at last.

if (root.isTerminating) { if (checkWordForPalindrome (word)) { return true; }
}
for (TrieNode childNode: root.children) {

if (childNode == null) {

continue;

}

String fwd = word + childNode.data;

if (checkRemainingBranches InTrie (childNode, fwd)) {

return true;

}

}

return false;

}

private static boolean checkWordForPalindrome (String word) {

int startIndex = 0;

int endIndex word.length() - 1;

while (startIndex < endIndex) {
if (word.charAt(startIndex) != word.charAt(endIndex)) {

return false;

}

startIndex += 1;

endIndex -= 1;

}

return true;
}



n.,...

public class Solution {

    public static boolean isPalindrome(Node<Integer> head) {
        if (head == null || head.next == null) {
            return true; // An empty list or a single-element list is always a palindrome
        }

        // Step 1: Find the middle of the linked list
        Node<Integer> slow = head;
        Node<Integer> fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Step 2: Reverse the second half of the linked list
        Node<Integer> secondHalfHead = reverse(slow);

        // Step 3: Compare the first half with the reversed second half
        Node<Integer> firstHalfPointer = head;
        Node<Integer> secondHalfPointer = secondHalfHead;

        boolean isPalindrome = true;
        while (secondHalfPointer != null) {
            if (!firstHalfPointer.data.equals(secondHalfPointer.data)) {
                isPalindrome = false;
                break;
            }
            firstHalfPointer = firstHalfPointer.next;
            secondHalfPointer = secondHalfPointer.next;
        }

        // Optional Step 4: Restore the original structure of the list
        reverse(secondHalfHead);

        return isPalindrome;
    }

    private static Node<Integer> reverse(Node<Integer> head) {
        Node<Integer> prev = null;
        Node<Integer> current = head;

        while (current != null) {
            Node<Integer> nextNode = current.next;
            current.next = prev;
            prev = current;
            current = nextNode;
        }

        return prev;
    }
}
